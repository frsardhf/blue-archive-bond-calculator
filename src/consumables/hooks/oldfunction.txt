// Process exp materials with shared pool of available reports
  const processExpMaterialsWithSharedPool = (
    upgrade: any,
    materialMap: Map<number, MaterialSummary>,
    availableExpReports: Map<number, number>,
    student: StudentProps
  ): number => {
    // Get all resources to access exp items
    const resources = getResources() || {};
    
    // Get the character XP table and character credit costs from data
    const characterXpTable = dataTable.character_xp || [];
    const characterXpCreditsTable = dataTable.character_credits || [];
    
    // Calculate total XP needed
    const currentLevel = upgrade.currentCharacterLevel;
    const targetLevel = upgrade.targetCharacterLevel;
    
    if (!characterXpTable.length || currentLevel >= targetLevel) return 0;
    
    // Calculate total XP needed
    const currentXp = characterXpTable[currentLevel - 1] || 0;
    const targetXp = characterXpTable[targetLevel - 1] || 0;
    const totalXpNeeded = Math.max(0, targetXp - currentXp);
    
    if (totalXpNeeded <= 0) return 0;
    
    // Calculate credits needed (using cumulative credits table)
    let totalCreditCost = 0;
    if (characterXpCreditsTable.length > 0) {
      const currentLevelCreditCost = currentLevel > 0 ? 
        characterXpCreditsTable[currentLevel - 1] : 0;
      const targetLevelCreditCost = targetLevel > 0 ? 
        characterXpCreditsTable[targetLevel - 1] : 0;
        
      totalCreditCost = targetLevelCreditCost - currentLevelCreditCost;
      
      if (totalCreditCost > 0) {
        // Add credits cost to material map
        updateMaterialMap(CREDITS_ID, totalCreditCost, materialMap);
        
        // Track student usage for credits
        if (student) {
          trackMaterialUsage(student, CREDITS_ID, totalCreditCost, 'level');
        }
      }
    }
    
    // Calculate exp reports needed
    let remainingXpNeeded = totalXpNeeded;
    
    // Create an array of exp items in descending order of exp value
    const expItems = [
      { id: 13, value: resources['13']?.ExpValue || 0 }, // Superior
      { id: 12, value: resources['12']?.ExpValue || 0 }, // Advanced
      { id: 11, value: resources['11']?.ExpValue || 0 }, // Normal
      { id: 10, value: resources['10']?.ExpValue || 0 }  // Novice
    ].filter(item => item.value > 0);
    
    // Calculate how many of each report we need based on available reports
    expItems.forEach(item => {
      if (remainingXpNeeded <= 0) return;
      
      const expValue = item.value;
      const available = availableExpReports.get(item.id) || 0;
      
      if (available > 0) {
        // Calculate how many of this report we need
        const neededCount = Math.ceil(remainingXpNeeded / expValue);
        const useCount = Math.min(available, neededCount);
        
        if (useCount > 0) {
          // Add to material map
          updateMaterialMap(item.id, useCount, materialMap);
          
          // Track student usage for this exp report
          if (student) {
            trackMaterialUsage(student, item.id, useCount, 'level');
          }
          
          // Update available quantity
          availableExpReports.set(item.id, available - useCount);
          
          // Update remaining XP needed
          remainingXpNeeded -= useCount * expValue;
        }
      }
    });
    
    // If we still need more XP, add additional reports (beyond what's available)
    if (remainingXpNeeded > 0) {
      for (const item of expItems) {
        if (remainingXpNeeded <= 0) break;
        
        const expValue = item.value;
        // How many more of this report do we need
        const additionalCount = Math.floor(remainingXpNeeded / expValue);
        
        if (additionalCount > 0) {
          // Check if material is already in the map
          const existing = materialMap.get(item.id);
          if (existing) {
            existing.materialQuantity += additionalCount;
            existing.remaining = existing.owned - existing.materialQuantity;
          } else {
            // Add to material map
            updateMaterialMap(item.id, additionalCount, materialMap);
          }
          
          // Track student usage for this exp report
          if (student) {
            trackMaterialUsage(student, item.id, additionalCount, 'level');
          }
          
          // Update remaining XP needed
          remainingXpNeeded -= additionalCount * expValue;
        }
      }
      
      // Handle any remaining XP with the smallest report (round up)
      if (remainingXpNeeded > 0 && expItems.length > 0) {
        const smallestExp = expItems[expItems.length - 1];
        
        // Check if material is already in the map
        const existing = materialMap.get(smallestExp.id);
        if (existing) {
          existing.materialQuantity += 1;
          existing.remaining = existing.owned - existing.materialQuantity;
        } else {
          // Add to material map
          updateMaterialMap(smallestExp.id, 1, materialMap);
        }
        
        // Track student usage for this exp report
        if (student) {
          trackMaterialUsage(student, smallestExp.id, 1, 'level');
        }
      }
    }
    
    return totalCreditCost;
  };